{"ast":null,"code":"var util = require('util');\n\nvar Duplex = require('stream').Duplex;\n\nvar bind = require('component-bind');\n\nvar uuid = require('./uuid');\n\nvar debug = require('debug')('socket.io-stream:iostream');\n\nmodule.exports = IOStream;\nutil.inherits(IOStream, Duplex);\n/**\n * Duplex\n *\n * @param {Object} options\n * @api private\n */\n\nfunction IOStream(options) {\n  if (!(this instanceof IOStream)) {\n    return new IOStream(options);\n  }\n\n  IOStream.super_.call(this, options);\n  this.options = options;\n  this.id = uuid();\n  this.socket = null; // Buffers\n\n  this.pushBuffer = [];\n  this.writeBuffer = []; // Op states\n\n  this._readable = false;\n  this._writable = false;\n  this.destroyed = false; // default to *not* allowing half open sockets\n\n  this.allowHalfOpen = options && options.allowHalfOpen || false;\n  this.on('finish', this._onfinish);\n  this.on('end', this._onend);\n  this.on('error', this._onerror);\n}\n/**\n * Ensures that no more I/O activity happens on this stream.\n * Not necessary in the usual case.\n *\n * @api public\n */\n\n\nIOStream.prototype.destroy = function () {\n  debug('destroy');\n\n  if (this.destroyed) {\n    debug('already destroyed');\n    return;\n  }\n\n  this.readable = this.writable = false;\n\n  if (this.socket) {\n    debug('clean up');\n    this.socket.cleanup(this.id);\n    this.socket = null;\n  }\n\n  this.destroyed = true;\n};\n/**\n * Local read\n *\n * @api private\n */\n\n\nIOStream.prototype._read = function (size) {\n  var push; // We can not read from the socket if it's destroyed obviously ...\n\n  if (this.destroyed) return;\n\n  if (this.pushBuffer.length) {\n    // flush buffer and end if it exists.\n    while (push = this.pushBuffer.shift()) {\n      if (!push()) break;\n    }\n\n    return;\n  }\n\n  this._readable = true; // Go get data from remote stream\n  // Calls\n  // ._onread remotely\n  // then\n  // ._onwrite locally\n\n  this.socket._read(this.id, size);\n};\n/**\n * Read from remote stream\n *\n * @api private\n */\n\n\nIOStream.prototype._onread = function (size) {\n  var write = this.writeBuffer.shift();\n  if (write) return write();\n  this._writable = true;\n};\n/**\n * Write local data to remote stream\n * Calls\n * remtote ._onwrite\n *\n * @api private\n */\n\n\nIOStream.prototype._write = function (chunk, encoding, callback) {\n  var self = this;\n\n  function write() {\n    // We can not write to the socket if it's destroyed obviously ...\n    if (self.destroyed) return;\n    self._writable = false;\n\n    self.socket._write(self.id, chunk, encoding, callback);\n  }\n\n  if (this._writable) {\n    write();\n  } else {\n    this.writeBuffer.push(write);\n  }\n};\n/**\n * Write the data fetched remotely\n * so that we can now read locally\n *\n * @api private\n */\n\n\nIOStream.prototype._onwrite = function (chunk, encoding, callback) {\n  var self = this;\n\n  function push() {\n    self._readable = false;\n    var ret = self.push(chunk || '', encoding);\n    callback();\n    return ret;\n  }\n\n  if (this._readable) {\n    push();\n  } else {\n    this.pushBuffer.push(push);\n  }\n};\n/**\n * When ending send 'end' event to remote stream\n *\n * @api private\n */\n\n\nIOStream.prototype._end = function () {\n  if (this.pushBuffer.length) {\n    // end after flushing buffer.\n    this.pushBuffer.push(bind(this, '_done'));\n  } else {\n    this._done();\n  }\n};\n/**\n * Remote stream just ended\n *\n * @api private\n */\n\n\nIOStream.prototype._done = function () {\n  this._readable = false; // signal the end of the data.\n\n  return this.push(null);\n};\n/**\n * the user has called .end(), and all the bytes have been\n * sent out to the other side.\n * If allowHalfOpen is false, or if the readable side has\n * ended already, then destroy.\n * If allowHalfOpen is true, then we need to set writable false,\n * so that only the writable side will be cleaned up.\n *\n * @api private\n */\n\n\nIOStream.prototype._onfinish = function () {\n  debug('_onfinish'); // Local socket just finished\n  // send 'end' event to remote\n\n  if (this.socket) {\n    this.socket._end(this.id);\n  }\n\n  this.writable = false;\n  this._writableState.ended = true;\n\n  if (!this.readable || this._readableState.ended) {\n    debug('_onfinish: ended, destroy %s', this._readableState);\n    return this.destroy();\n  }\n\n  debug('_onfinish: not ended');\n\n  if (!this.allowHalfOpen) {\n    this.push(null); // just in case we're waiting for an EOF.\n\n    if (this.readable && !this._readableState.endEmitted) {\n      this.read(0);\n    }\n  }\n};\n/**\n * the EOF has been received, and no more bytes are coming.\n * if the writable side has ended already, then clean everything\n * up.\n *\n * @api private\n */\n\n\nIOStream.prototype._onend = function () {\n  debug('_onend');\n  this.readable = false;\n  this._readableState.ended = true;\n\n  if (!this.writable || this._writableState.finished) {\n    debug('_onend: %s', this._writableState);\n    return this.destroy();\n  }\n\n  debug('_onend: not finished');\n\n  if (!this.allowHalfOpen) {\n    this.end();\n  }\n};\n/**\n * When error in local stream\n * notyify remote\n * if err.remote = true\n * then error happened on remote stream\n *\n * @api private\n */\n\n\nIOStream.prototype._onerror = function (err) {\n  // check if the error came from remote stream.\n  if (!err.remote && this.socket) {\n    // notify the error to the corresponding remote stream.\n    this.socket._error(this.id, err);\n  }\n\n  this.destroy();\n};","map":{"version":3,"sources":["E:/video_project/client/node_modules/socket.io-stream/lib/iostream.js"],"names":["util","require","Duplex","bind","uuid","debug","module","exports","IOStream","inherits","options","super_","call","id","socket","pushBuffer","writeBuffer","_readable","_writable","destroyed","allowHalfOpen","on","_onfinish","_onend","_onerror","prototype","destroy","readable","writable","cleanup","_read","size","push","length","shift","_onread","write","_write","chunk","encoding","callback","self","_onwrite","ret","_end","_done","_writableState","ended","_readableState","endEmitted","read","finished","end","err","remote","_error"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAP,CAAkBC,MAA/B;;AACA,IAAIC,IAAI,GAAGF,OAAO,CAAC,gBAAD,CAAlB;;AACA,IAAIG,IAAI,GAAGH,OAAO,CAAC,QAAD,CAAlB;;AACA,IAAII,KAAK,GAAGJ,OAAO,CAAC,OAAD,CAAP,CAAiB,2BAAjB,CAAZ;;AAGAK,MAAM,CAACC,OAAP,GAAiBC,QAAjB;AAEAR,IAAI,CAACS,QAAL,CAAcD,QAAd,EAAwBN,MAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASM,QAAT,CAAkBE,OAAlB,EAA2B;AACzB,MAAI,EAAE,gBAAgBF,QAAlB,CAAJ,EAAiC;AAC/B,WAAO,IAAIA,QAAJ,CAAaE,OAAb,CAAP;AACD;;AAEDF,EAAAA,QAAQ,CAACG,MAAT,CAAgBC,IAAhB,CAAqB,IAArB,EAA2BF,OAA3B;AAEA,OAAKA,OAAL,GAAeA,OAAf;AACA,OAAKG,EAAL,GAAUT,IAAI,EAAd;AACA,OAAKU,MAAL,GAAc,IAAd,CATyB,CAWzB;;AACA,OAAKC,UAAL,GAAkB,EAAlB;AACA,OAAKC,WAAL,GAAmB,EAAnB,CAbyB,CAezB;;AACA,OAAKC,SAAL,GAAiB,KAAjB;AACA,OAAKC,SAAL,GAAiB,KAAjB;AACA,OAAKC,SAAL,GAAiB,KAAjB,CAlByB,CAoBzB;;AACA,OAAKC,aAAL,GAAqBV,OAAO,IAAIA,OAAO,CAACU,aAAnB,IAAoC,KAAzD;AAEA,OAAKC,EAAL,CAAQ,QAAR,EAAkB,KAAKC,SAAvB;AACA,OAAKD,EAAL,CAAQ,KAAR,EAAe,KAAKE,MAApB;AACA,OAAKF,EAAL,CAAQ,OAAR,EAAiB,KAAKG,QAAtB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACAhB,QAAQ,CAACiB,SAAT,CAAmBC,OAAnB,GAA6B,YAAW;AACtCrB,EAAAA,KAAK,CAAC,SAAD,CAAL;;AAEA,MAAI,KAAKc,SAAT,EAAoB;AAClBd,IAAAA,KAAK,CAAC,mBAAD,CAAL;AACA;AACD;;AAED,OAAKsB,QAAL,GAAgB,KAAKC,QAAL,GAAgB,KAAhC;;AAEA,MAAI,KAAKd,MAAT,EAAiB;AACfT,IAAAA,KAAK,CAAC,UAAD,CAAL;AACA,SAAKS,MAAL,CAAYe,OAAZ,CAAoB,KAAKhB,EAAzB;AACA,SAAKC,MAAL,GAAc,IAAd;AACD;;AAED,OAAKK,SAAL,GAAiB,IAAjB;AACD,CAjBD;AAmBA;AACA;AACA;AACA;AACA;;;AACAX,QAAQ,CAACiB,SAAT,CAAmBK,KAAnB,GAA2B,UAASC,IAAT,EAAe;AACxC,MAAIC,IAAJ,CADwC,CAGxC;;AACA,MAAI,KAAKb,SAAT,EAAoB;;AAEpB,MAAI,KAAKJ,UAAL,CAAgBkB,MAApB,EAA4B;AAC1B;AACA,WAAOD,IAAI,GAAG,KAAKjB,UAAL,CAAgBmB,KAAhB,EAAd,EAAuC;AACrC,UAAI,CAACF,IAAI,EAAT,EAAa;AACd;;AACD;AACD;;AAED,OAAKf,SAAL,GAAiB,IAAjB,CAdwC,CAgBxC;AACA;AACA;AACA;AACA;;AACA,OAAKH,MAAL,CAAYgB,KAAZ,CAAkB,KAAKjB,EAAvB,EAA2BkB,IAA3B;AACD,CAtBD;AAyBA;AACA;AACA;AACA;AACA;;;AACAvB,QAAQ,CAACiB,SAAT,CAAmBU,OAAnB,GAA6B,UAASJ,IAAT,EAAe;AAC1C,MAAIK,KAAK,GAAG,KAAKpB,WAAL,CAAiBkB,KAAjB,EAAZ;AACA,MAAIE,KAAJ,EAAW,OAAOA,KAAK,EAAZ;AAEX,OAAKlB,SAAL,GAAiB,IAAjB;AACD,CALD;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAV,QAAQ,CAACiB,SAAT,CAAmBY,MAAnB,GAA4B,UAASC,KAAT,EAAgBC,QAAhB,EAA0BC,QAA1B,EAAoC;AAC9D,MAAIC,IAAI,GAAG,IAAX;;AAEA,WAASL,KAAT,GAAiB;AACf;AACA,QAAIK,IAAI,CAACtB,SAAT,EAAoB;AAEpBsB,IAAAA,IAAI,CAACvB,SAAL,GAAiB,KAAjB;;AACAuB,IAAAA,IAAI,CAAC3B,MAAL,CAAYuB,MAAZ,CAAmBI,IAAI,CAAC5B,EAAxB,EAA4ByB,KAA5B,EAAmCC,QAAnC,EAA6CC,QAA7C;AACD;;AAED,MAAI,KAAKtB,SAAT,EAAoB;AAClBkB,IAAAA,KAAK;AACN,GAFD,MAEO;AACL,SAAKpB,WAAL,CAAiBgB,IAAjB,CAAsBI,KAAtB;AACD;AACF,CAhBD;AAkBA;AACA;AACA;AACA;AACA;AACA;;;AACA5B,QAAQ,CAACiB,SAAT,CAAmBiB,QAAnB,GAA8B,UAASJ,KAAT,EAAgBC,QAAhB,EAA0BC,QAA1B,EAAoC;AAChE,MAAIC,IAAI,GAAG,IAAX;;AAEA,WAAST,IAAT,GAAgB;AACdS,IAAAA,IAAI,CAACxB,SAAL,GAAiB,KAAjB;AACA,QAAI0B,GAAG,GAAGF,IAAI,CAACT,IAAL,CAAUM,KAAK,IAAI,EAAnB,EAAuBC,QAAvB,CAAV;AACAC,IAAAA,QAAQ;AACR,WAAOG,GAAP;AACD;;AAED,MAAI,KAAK1B,SAAT,EAAoB;AAClBe,IAAAA,IAAI;AACL,GAFD,MAEO;AACL,SAAKjB,UAAL,CAAgBiB,IAAhB,CAAqBA,IAArB;AACD;AACF,CAfD;AAiBA;AACA;AACA;AACA;AACA;;;AACAxB,QAAQ,CAACiB,SAAT,CAAmBmB,IAAnB,GAA0B,YAAW;AACnC,MAAI,KAAK7B,UAAL,CAAgBkB,MAApB,EAA4B;AAC1B;AACA,SAAKlB,UAAL,CAAgBiB,IAAhB,CAAqB7B,IAAI,CAAC,IAAD,EAAO,OAAP,CAAzB;AACD,GAHD,MAGO;AACL,SAAK0C,KAAL;AACD;AACF,CAPD;AASA;AACA;AACA;AACA;AACA;;;AACArC,QAAQ,CAACiB,SAAT,CAAmBoB,KAAnB,GAA2B,YAAW;AACpC,OAAK5B,SAAL,GAAiB,KAAjB,CADoC,CAGpC;;AACA,SAAO,KAAKe,IAAL,CAAU,IAAV,CAAP;AACD,CALD;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxB,QAAQ,CAACiB,SAAT,CAAmBH,SAAnB,GAA+B,YAAW;AACxCjB,EAAAA,KAAK,CAAC,WAAD,CAAL,CADwC,CAExC;AACA;;AACA,MAAI,KAAKS,MAAT,EAAiB;AACf,SAAKA,MAAL,CAAY8B,IAAZ,CAAiB,KAAK/B,EAAtB;AACD;;AAED,OAAKe,QAAL,GAAgB,KAAhB;AACA,OAAKkB,cAAL,CAAoBC,KAApB,GAA4B,IAA5B;;AAEA,MAAI,CAAC,KAAKpB,QAAN,IAAkB,KAAKqB,cAAL,CAAoBD,KAA1C,EAAiD;AAC/C1C,IAAAA,KAAK,CAAC,8BAAD,EAAiC,KAAK2C,cAAtC,CAAL;AACA,WAAO,KAAKtB,OAAL,EAAP;AACD;;AAEDrB,EAAAA,KAAK,CAAC,sBAAD,CAAL;;AAEA,MAAI,CAAC,KAAKe,aAAV,EAAyB;AACvB,SAAKY,IAAL,CAAU,IAAV,EADuB,CAGvB;;AACA,QAAI,KAAKL,QAAL,IAAiB,CAAC,KAAKqB,cAAL,CAAoBC,UAA1C,EAAsD;AACpD,WAAKC,IAAL,CAAU,CAAV;AACD;AACF;AACF,CA1BD;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA1C,QAAQ,CAACiB,SAAT,CAAmBF,MAAnB,GAA4B,YAAW;AACrClB,EAAAA,KAAK,CAAC,QAAD,CAAL;AACA,OAAKsB,QAAL,GAAgB,KAAhB;AACA,OAAKqB,cAAL,CAAoBD,KAApB,GAA4B,IAA5B;;AAEA,MAAI,CAAC,KAAKnB,QAAN,IAAkB,KAAKkB,cAAL,CAAoBK,QAA1C,EAAoD;AAClD9C,IAAAA,KAAK,CAAC,YAAD,EAAe,KAAKyC,cAApB,CAAL;AACA,WAAO,KAAKpB,OAAL,EAAP;AACD;;AAEDrB,EAAAA,KAAK,CAAC,sBAAD,CAAL;;AAEA,MAAI,CAAC,KAAKe,aAAV,EAAyB;AACvB,SAAKgC,GAAL;AACD;AACF,CAfD;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA5C,QAAQ,CAACiB,SAAT,CAAmBD,QAAnB,GAA8B,UAAS6B,GAAT,EAAc;AAC1C;AACA,MAAI,CAACA,GAAG,CAACC,MAAL,IAAe,KAAKxC,MAAxB,EAAgC;AAC9B;AACA,SAAKA,MAAL,CAAYyC,MAAZ,CAAmB,KAAK1C,EAAxB,EAA4BwC,GAA5B;AACD;;AAED,OAAK3B,OAAL;AACD,CARD","sourcesContent":["var util = require('util');\nvar Duplex = require('stream').Duplex;\nvar bind = require('component-bind');\nvar uuid = require('./uuid');\nvar debug = require('debug')('socket.io-stream:iostream');\n\n\nmodule.exports = IOStream;\n\nutil.inherits(IOStream, Duplex);\n\n/**\n * Duplex\n *\n * @param {Object} options\n * @api private\n */\nfunction IOStream(options) {\n  if (!(this instanceof IOStream)) {\n    return new IOStream(options);\n  }\n\n  IOStream.super_.call(this, options);\n\n  this.options = options;\n  this.id = uuid();\n  this.socket = null;\n\n  // Buffers\n  this.pushBuffer = [];\n  this.writeBuffer = [];\n\n  // Op states\n  this._readable = false;\n  this._writable = false;\n  this.destroyed = false;\n\n  // default to *not* allowing half open sockets\n  this.allowHalfOpen = options && options.allowHalfOpen || false;\n\n  this.on('finish', this._onfinish);\n  this.on('end', this._onend);\n  this.on('error', this._onerror);\n}\n\n/**\n * Ensures that no more I/O activity happens on this stream.\n * Not necessary in the usual case.\n *\n * @api public\n */\nIOStream.prototype.destroy = function() {\n  debug('destroy');\n\n  if (this.destroyed) {\n    debug('already destroyed');\n    return;\n  }\n\n  this.readable = this.writable = false;\n\n  if (this.socket) {\n    debug('clean up');\n    this.socket.cleanup(this.id);\n    this.socket = null;\n  }\n\n  this.destroyed = true;\n};\n\n/**\n * Local read\n *\n * @api private\n */\nIOStream.prototype._read = function(size) {\n  var push;\n\n  // We can not read from the socket if it's destroyed obviously ...\n  if (this.destroyed) return;\n\n  if (this.pushBuffer.length) {\n    // flush buffer and end if it exists.\n    while (push = this.pushBuffer.shift()) {\n      if (!push()) break;\n    }\n    return;\n  }\n\n  this._readable = true;\n\n  // Go get data from remote stream\n  // Calls\n  // ._onread remotely\n  // then\n  // ._onwrite locally\n  this.socket._read(this.id, size);\n};\n\n\n/**\n * Read from remote stream\n *\n * @api private\n */\nIOStream.prototype._onread = function(size) {\n  var write = this.writeBuffer.shift();\n  if (write) return write();\n\n  this._writable = true;\n};\n\n/**\n * Write local data to remote stream\n * Calls\n * remtote ._onwrite\n *\n * @api private\n */\nIOStream.prototype._write = function(chunk, encoding, callback) {\n  var self = this;\n\n  function write() {\n    // We can not write to the socket if it's destroyed obviously ...\n    if (self.destroyed) return;\n\n    self._writable = false;\n    self.socket._write(self.id, chunk, encoding, callback);\n  }\n\n  if (this._writable) {\n    write();\n  } else {\n    this.writeBuffer.push(write);\n  }\n};\n\n/**\n * Write the data fetched remotely\n * so that we can now read locally\n *\n * @api private\n */\nIOStream.prototype._onwrite = function(chunk, encoding, callback) {\n  var self = this;\n\n  function push() {\n    self._readable = false;\n    var ret = self.push(chunk || '', encoding);\n    callback();\n    return ret;\n  }\n\n  if (this._readable) {\n    push();\n  } else {\n    this.pushBuffer.push(push);\n  }\n};\n\n/**\n * When ending send 'end' event to remote stream\n *\n * @api private\n */\nIOStream.prototype._end = function() {\n  if (this.pushBuffer.length) {\n    // end after flushing buffer.\n    this.pushBuffer.push(bind(this, '_done'));\n  } else {\n    this._done();\n  }\n};\n\n/**\n * Remote stream just ended\n *\n * @api private\n */\nIOStream.prototype._done = function() {\n  this._readable = false;\n\n  // signal the end of the data.\n  return this.push(null);\n};\n\n/**\n * the user has called .end(), and all the bytes have been\n * sent out to the other side.\n * If allowHalfOpen is false, or if the readable side has\n * ended already, then destroy.\n * If allowHalfOpen is true, then we need to set writable false,\n * so that only the writable side will be cleaned up.\n *\n * @api private\n */\nIOStream.prototype._onfinish = function() {\n  debug('_onfinish');\n  // Local socket just finished\n  // send 'end' event to remote\n  if (this.socket) {\n    this.socket._end(this.id);\n  }\n\n  this.writable = false;\n  this._writableState.ended = true;\n\n  if (!this.readable || this._readableState.ended) {\n    debug('_onfinish: ended, destroy %s', this._readableState);\n    return this.destroy();\n  }\n\n  debug('_onfinish: not ended');\n\n  if (!this.allowHalfOpen) {\n    this.push(null);\n\n    // just in case we're waiting for an EOF.\n    if (this.readable && !this._readableState.endEmitted) {\n      this.read(0);\n    }\n  }\n};\n\n/**\n * the EOF has been received, and no more bytes are coming.\n * if the writable side has ended already, then clean everything\n * up.\n *\n * @api private\n */\nIOStream.prototype._onend = function() {\n  debug('_onend');\n  this.readable = false;\n  this._readableState.ended = true;\n\n  if (!this.writable || this._writableState.finished) {\n    debug('_onend: %s', this._writableState);\n    return this.destroy();\n  }\n\n  debug('_onend: not finished');\n\n  if (!this.allowHalfOpen) {\n    this.end();\n  }\n};\n\n/**\n * When error in local stream\n * notyify remote\n * if err.remote = true\n * then error happened on remote stream\n *\n * @api private\n */\nIOStream.prototype._onerror = function(err) {\n  // check if the error came from remote stream.\n  if (!err.remote && this.socket) {\n    // notify the error to the corresponding remote stream.\n    this.socket._error(this.id, err);\n  }\n\n  this.destroy();\n};\n"]},"metadata":{},"sourceType":"script"}